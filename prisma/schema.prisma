generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Setting {
  id     String  @id @default(cuid())
  userId String?
  key    String
  value  String

  @@unique([userId, key])
  @@index([key])
}

model User {
  id            String          @id @default(cuid())
  wallet        String?         @unique
  createdAt     DateTime        @default(now())
  metricsDaily  MetricsDaily[]
  metricsHourly MetricsHourly[]
  pointBalance  PointBalance?
  events        PointEvent[]
}

model PointEvent {
  id        String   @id @default(cuid())
  userId    String
  /// ประเภท event:
  /// - extension_farm     → reward จาก extension
  /// - referral           → แต้มจากเชิญเพื่อน
  /// - referral_bonus     → แต้มโบนัส
  /// - convert_debit      → ใช้แต้มไปแลก SLK (amount เป็นค่าลบ)
  /// - admin_adjust       → ปรับยอดด้วยมือ
  type      String
  /// จำนวนแต้มบน ledger:
  /// - earn  = ค่าบวก
  /// - spend = ค่าลบ (เช่น convert_debit)
  amount    Int
  meta      Json?
  createdAt DateTime @default(now())
  /// ป้องกัน double-spend / replay (ใส่ nonce จากฝั่ง client/api ได้)
  nonce     String?  @unique
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([type, createdAt])
}

model PointBalance {
  /// ใช้ userId เป็น primary key และ foreign key ไปที่ User.id
  userId    String   @id
  /// ยอดแต้มคงเหลือปัจจุบัน
  balance   Int      @default(0)
  updatedAt DateTime @updatedAt
  /// ยอด SLK off-chain ปัจจุบัน (ถ้าจะผูก on-chain ทีหลัง ให้เพิ่มตารางแยกได้)
  slk       Float    @default(0)
  user      User     @relation(fields: [userId], references: [id])
}

model MetricsHourly {
  id           String   @id @default(cuid())
  /// ตัวแทนช่วงชั่วโมงแบบ UTC (เช่น 2025-11-11T10:00:00Z)
  hourUtc      DateTime
  /// ผู้ใช้เป้าหมาย (ว่าง = แถวสรุปทั้งระบบ)
  userId       String?
  pointsEarned Int      @default(0)
  uptimePct    Float?
  avgBandwidth Float?
  qfScore      Float?
  trustScore   Float?
  createdAt    DateTime @default(now())
  ip           String?
  /// ✅ สถานะ node ล่าสุดในชั่วโมงนั้น
  region       String?
  version      String?
  user         User?    @relation(fields: [userId], references: [id])

  @@unique([hourUtc, userId], name: "hourUtc_userId_unique")
  @@index([hourUtc])
  @@index([userId])
}

model MetricsDaily {
  id           String   @id @default(cuid())
  /// ตัวแทนช่วงวันแบบ UTC (เช่น 2025-11-11T00:00:00Z)
  dayUtc       DateTime
  /// ผู้ใช้เป้าหมาย (ว่าง = แถวสรุปทั้งระบบ)
  userId       String?
  pointsEarned Int      @default(0)
  uptimePct    Float?
  avgBandwidth Float?
  qfScore      Float?
  trustScore   Float?
  createdAt    DateTime @default(now())
  ip           String?
  /// ✅ สถานะ node ล่าสุดในวันนั้น
  region       String?
  version      String?
  user         User?    @relation(fields: [userId], references: [id])

  @@unique([dayUtc, userId], name: "dayUtc_userId_unique")
  @@index([dayUtc])
  @@index([userId])
}

model ReferralCode {
  /// โค้ดที่ใช้ใน URL เช่น /r/abcd1234
  code      String   @id
  /// อ้างอิงถึง userId / wallet เจ้าของโค้ด (ใช้เป็น String ตรง ๆ)
  userId    String
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@index([userId])
}

model SharingState {
  id        String   @id @default(cuid())
  /// เก็บ wallet ตรง ๆ แบบ lowercase (จัดการตอนเขียนใน API)
  wallet    String   @unique
  /// true = กำลังแชร์ bandwidth, false = หยุดแชร์
  active    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
